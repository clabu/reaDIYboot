{"body":"**reaDIYboot** is a bootloader for the ATmega1280 microcontroller from Atmel.\r\nIt gives the ATmega1280 two ways of programming itself:\r\n\r\n1. Over a serial link using the STK500v1 protocol to receive new programs from avrdude\r\n2. Over the internet using a WiFly GSX/EZX Wi-Fi module from Roving Networks to retrieve new programs from a remote server\r\n\r\n## Hardware setup ##\r\n\r\nreaDIYboot has been tested with the WiFly GSX RN131 and the WiFly EZX RN171 modules.\r\n\r\nIt was developped for a custom board with the following wiring:\r\n\r\n1. Pin `RESET` of the WiFly to pin `PL0` of the ATmega1280\r\n2. Pin `UART_RX` to pin `PD3` (i.e `USART1_TX`)\r\n3. Pin `UART_TX` to pin `PD2` (i.e `USART1_RX`)\r\n4. Pin `GPIO4` to pin `PJ5`\r\n5. Pin `GPIO5` to pin `PJ6`\r\n6. Pin `GPIO6` to pin `PJ7`\r\n\r\nAll the I/O definitions are written at the beginning of the source code so you can easily change them.\r\n\r\n## WiFly firmware setup ##\r\n\r\nThis section explains how to configure a WiFly module to work with reaDIYboot.\r\n\r\nIt is recommended to update the firmware of the WiFly module as soon as possible - otherwise it might not work with some access points. To do this, use the `ftp update` command and don't forget to perform a `factory RESET` once the update is complete.\r\nAs of May 2012, the IP address of the FTP server hosting the WiFly firmware has changed. Therefore you'll need to redirect the module to the new IP address of the FTP server using the following command:\r\n\r\n    set ftp address 208.109.14.133\r\n    save\r\n\r\nBelow is the WiFly configuration used to test reaDIYboot.\r\n\r\nSetup the access point SSID and security phrase:\r\n\r\n    set wlan ssid <your SSID here>\r\n    set wlan phrase <your passphrase here>\r\n\r\nenable the link monitor threshold with the recommended value:\r\n\r\n    set wlan linkmon 5\r\n\r\ndisable access point autojoin:\r\n\r\n    set wlan join 0\r\n\r\ndisable the socket monitor strings:\r\n\r\n    set comm open 0\r\n    set comm close 0\r\n    set comm remote 0\r\n\r\ndisable echo of RX data and replace the version string with a single carriage return:\r\n\r\n    set uart mode 0x21\r\n    set opt replace 0xd\r\n\r\nenable DHCP cache mode:\r\n\r\n    set ip dhcp 3\r\n\r\nclose any open TCP connection when the connection to the access point is lost:\r\n\r\n    set ip flags 0x6\r\n\r\nforce DNS:\r\n\r\n    set ip tcp-mode 0x4\r\n\r\nenable the alternate functions of the LEDs:\r\n\r\n    set sys iofunc 0x70\r\n\r\nincrease the baudrate (250 kbaud yields 0.0% error with a 16 MHz crystal!)\r\n\r\n    set uart raw 250000\r\n\r\n\r\n## Compilation example 1 - building reaDIYboot for basic uploads ##\r\n\r\nSuppose you have a board with an ATmega1280 and you want to upload new programs on it over the internet.\r\n\r\n### 1. Setup the target program in the makefile\r\n\r\nYou need to specify a few parameters before compiling reaDIYboot.\r\n\r\nLet's say your program is located at the following URL: `http://somedomain.com/hexfiles/some_program.hex`\r\n\r\nThe first thing to do is to edit the makefile and set the right values for `PROGRAM_HOST` and `PROGRAM_PATH`.\r\n\r\nFind the following lines in the makefile:\r\n\r\n    PROGRAM_HOST = \"\"\r\n    PROGRAM_PATH = \"\"\r\n\r\nand edit them as shown below:\r\n\r\n    PROGRAM_HOST = \"somedomain.com\"\r\n    PROGRAM_PATH = \"/hexfiles/some_program.hex\"\r\n\r\nYou can also set the User Agent string to whatever you want.\r\n\r\n### 2. Compile reaDIYboot\r\n\r\n    make clean\r\n    make all\r\n\r\nNotice that the makefile calls the `avr-size` utility to display the size of the compiled bootloader. Unless you have a *really* long URL, it should still be well under the 4kB boundary.\r\n\r\n### 3. Burn reaDIYboot to the ATmega1280\r\n\r\n### 4. You're done!\r\n\r\nNow you have two ways of loading a new program onto the microcontroller:\r\n\r\n1. Plug your board to a computer and use the Upload function of the Arduino IDE (or use avrdude directly).\r\n2. Compile your program, rename the corresponding HEX file to `some_program.hex` and upload it to `somedomain.com/hexfiles/`\r\n\r\nIf the bootloader doesn't detect a computer trying to upload a new program when it starts, it is going to send a request to `somedomain.com` in order to determine whether `/hexfiles/some_program.hex` exists. If the file does exist, the bootloader will download it, write it to the Flash memory and run it after a reset.\r\n\r\n## Compilation example 2 - building reaDIYboot for adaptative uploads ##\r\n\r\nThe previous method has a major inconvenience: the only way to prevent the microcontroller from downloading the same program every single time it resets is to remove the HEX file from the server.\r\n\r\nFortunately there are two options that you can enable in the makefile to help with this.\r\n\r\nWith the `CHECK_STATUS_BEFORE_DOWNLOAD` option enabled, the bootloader will send an HTTP request to the server before it tries to download the program, and if it doesn't receive the expected response it will skip the update.\r\n\r\nWith the `CLEAR_STATUS_AFTER_DOWNLOAD` option enabled, the bootloader will send an HTTP request to the server after an update has been successfully completed.\r\n\r\nSince you can also specify which requests are sent, you can use these options to make specific calls on an API, which makes update management much more flexible.\r\n\r\n### 1. Setup the API calls in the makefile\r\n\r\nLet's say you have two scripts:\r\n\r\n    somedomain.com/api/check_status.php\r\n    somedomain.com/api/clear_status.php\r\nwhich are written so that `check_status.php` returns `{\"status\":1}` until `clear_status.php` has been called, and `{\"status\":0}` afterwards.\r\n\r\nIn the makefile, uncomment the following two lines, which are commented by default:\r\n\r\n    CFLAGS += -DCHECK_STATUS_BEFORE_DOWNLOAD\r\n    CFLAGS += -DCLEAR_STATUS_AFTER_DOWNLOAD\r\n\r\nFind the following lines in the makefile:\r\n\r\n    CHECK_STATUS_REQUEST = \"\"\r\n    CLEAR_STATUS_REQUEST = \"\"\r\n    CHECK_STATUS_EXPECTED_RESPONSE = \"\"\r\n\r\nand edit them as shown below:\r\n\r\n    CHECK_STATUS_REQUEST = \"/api/check_status.php\"\r\n    CLEAR_STATUS_REQUEST = \"/api/clear_status.php\"\r\n    CHECK_STATUS_EXPECTED_RESPONSE = \"{\\\"status\\\":1}\"\r\n\r\n### 2. Compile reaDIYboot\r\n\r\nLike in Example 1, the compiled bootloader should still be less than 4096 bytes (using the strings from my example, I get 3798 bytes).\r\n\r\n### 3. Burn the bootloader\r\n\r\n### 4. You're done!\r\n\r\n## A few more ideas ##\r\n\r\nreaDIYboot is still in an early stage and there is still room for many improvements.\r\n\r\nIt has been successfully tested with program sizes up to 128kB.\r\n\r\nRobustness could be increased by adding CRC computations and/or appending specific markers to the programs before writing them to the Flash memory.\r\n\r\n***\r\n\r\n**reaDIYboot** is being developped as part of the [reaDIYmate](http://readiymate.com) platform.\r\n","tagline":"Wi-Fi/STK500 dual bootloader for the ATmega1280","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"reaDIYboot","google":""}